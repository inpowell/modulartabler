% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BaseMappingTable.R
\name{BaseMappingTable}
\alias{BaseMappingTable}
\title{R6 class representing a mapping table for a single dimension.}
\description{
This mapping table class defines the structure for a single dimension of a
count table. It is defined by a potentially many-to-many map from raw data to
table categories.
}
\examples{
# Create a mapping table that maps iris species to their abbreviated binomial
# nomenclature, and includes a total.
species_table <- data.frame(
  Species = factor(
    c(1L, 2L, 3L, rep(4L, times = 3L)),
    labels = c("I. setosa", "I. versicolor", "I. virginica", "Total")
  ),
  .rawspecies = factor(rep(c("setosa", "versicolor", "virginica"), times = 2L))
)
species_table

SpeciesMap <- BaseMappingTable$new(
  species_table,
  raw_cols = ".rawspecies",
  table_cols = "Species",
  data_cols = "Species"
)
SpeciesMap

# Get the counts in each category in long format
SpeciesMap$count_aggregate(iris)

# Show the relationships in the output table. This matrix tells us that
# I. setosa + I. versicolor + I. virginica - Total = 0. This is
# necessary for preventing back-calculation in cell suppression.
SpeciesMap$nullspace
# Sometimes we need a more complicated table, which often requires some fiddly
# data manipulation.
library(dplyr)

# In AER::Fertility, these are recorded as factors - we will recode later
ethtab <- expand.grid(
  afam = c(TRUE, FALSE),
  hispanic = c(TRUE, FALSE),
  other = c(TRUE, FALSE)
)

# Build the output categories. We code as factor so it sorts properly in the
# output
ethtab <- ethtab |>
  mutate(Ethnicity = as.factor(case_when(
    afam & !hispanic & !other ~ 'African-American only',
    !afam & hispanic & !other ~ 'Hispanic only',
    !afam & !hispanic & !other ~ 'Caucasian only',
    TRUE ~ 'Other or multiple ethnicities'
  )))

# Using factor() and bind_rows() means new levels get appended at the end
ethtab2 <- bind_rows(
  ethtab,
  # Subtotals for individual races
  filter(ethtab, afam) |> mutate(Ethnicity = factor('Any African-American')),
  filter(ethtab, hispanic) |> mutate(Ethnicity = factor('Any Hispanic')),
  filter(ethtab, other) |> mutate(Ethnicity = factor('Any other ethnicity')),
  # Grand total
  mutate(ethtab, Ethnicity = factor('Total'))
) |>
  # Recode inputs to match original data
  mutate(across(
    where(is.logical),
    \(x) factor(x, levels = c(FALSE, TRUE), labels = c('no', 'yes'))
  ))

# Now we can create the mapping table!
EthnicityMap <- BaseMappingTable$new(
  ethtab2,
  raw_cols = c('afam', 'hispanic', 'other'),
  table_cols = 'Ethnicity'
)

# Use this mapping table to conduct some counts on ethnicity
data('Fertility', package = 'AER')
EthnicityMap$count_aggregate(Fertility)
}
\section{Super class}{
\code{\link[modulartabler:MappingTable]{modulartabler::MappingTable}} -> \code{BaseMappingTable}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{map}}{The data frame used for mapping.}

\item{\code{mraw}}{The raw-side data that correspond to rows of the matrix
representation.}

\item{\code{mtab}}{The table-side data that corresponds to columns of the matrix
representation.}

\item{\code{matrix}}{A matrix representation of the mapping table that indicates
which raw values (in rows) are mapped to table cells (in columns).}

\item{\code{raw_cols}}{The names of columns in \code{map} that are joined with
preprocessed data.}

\item{\code{data_cols}}{The names of columns in the preprocessed data that are joined
with \code{map}.}

\item{\code{table_cols}}{The names of columns in the output dataset.}

\item{\code{join_clause}}{A \code{\link[dplyr:join_by]{dplyr::join_by()}} object that describes how to join
the data (in \code{x}) to the mapping table (in \code{y}).}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-BaseMappingTable-new}{\code{BaseMappingTable$new()}}
\item \href{#method-BaseMappingTable-clone}{\code{BaseMappingTable$clone()}}
}
}
\if{html}{\out{
<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="modulartabler" data-topic="MappingTable" data-id="count_aggregate"><a href='../../modulartabler/html/MappingTable.html#method-MappingTable-count_aggregate'><code>modulartabler::MappingTable$count_aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="modulartabler" data-topic="MappingTable" data-id="preprocess"><a href='../../modulartabler/html/MappingTable.html#method-MappingTable-preprocess'><code>modulartabler::MappingTable$preprocess()</code></a></span></li>
<li><span class="pkg-link" data-pkg="modulartabler" data-topic="MappingTable" data-id="print"><a href='../../modulartabler/html/MappingTable.html#method-MappingTable-print'><code>modulartabler::MappingTable$print()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BaseMappingTable-new"></a>}}
\if{latex}{\out{\hypertarget{method-BaseMappingTable-new}{}}}
\subsection{Method \code{new()}}{
Create a new mapping table object. The order of column names
in \code{raw_cols}, \code{table_cols}, and \code{data_cols} should match.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseMappingTable$new(map, raw_cols, table_cols, data_cols = raw_cols)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{map}}{A data frame defining the structure of the presentation
table in terms of raw columns. Note that the raw columns must have the
same type and values in the raw dataset to count, so factors should
match to factors, character to character. This is particularly
important for ordered factors.}

\item{\code{raw_cols}}{The names of raw columns in \code{map}.}

\item{\code{table_cols}}{The names of presentation columns in \code{map}.}

\item{\code{data_cols}}{The names of raw columns in the raw data. This is only
necessary if \code{raw_cols} does not match the names in the raw data.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{MappingTable} object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BaseMappingTable-clone"></a>}}
\if{latex}{\out{\hypertarget{method-BaseMappingTable-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BaseMappingTable$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
